use std::path::{Path, PathBuf};

use serde::Deserialize;
use std::fs;
use std::io::Error as IoError;
use std::process::{Child, Command};

use super::error::ConfigError;


/// Simple module providing scope for functions providing the default values when deserializing
/// [ClientConfig] from a config file.
mod defaults {
    use std::path::PathBuf;

    pub fn default_concurrent_run() -> bool {
        false
    }

    pub fn default_script_dir() -> PathBuf {
        PathBuf::from("/etc/nub.d/scripts")
    }

    pub fn default_pcaps_dir() -> PathBuf {
        PathBuf::from("/etc/nub.d/pcaps")
    }
}


/// Represents basic client configuration
/// todo: specify pcap backup
/// todo: allow configure the pcap filter
/// todo: configure capture buffer size
#[derive(Deserialize)]
pub struct ClientConfig {
    /// the path to the directory which holds the client test scripts, these scripts should expect
    /// to receive any arguments as they will receive none
    #[serde(default = "defaults::default_script_dir")]
    script_dir: PathBuf,

    /// the directory in which to store the pcap generated by the scripts in [script_dir]
    #[serde(default = "defaults::default_pcaps_dir")]
    pcap_dir: PathBuf,

    /// allow all scripts to be executed at once rather then one at a time
    #[serde(default = "defaults::default_concurrent_run")]
    allow_concurrent: bool,

    /// the list of interfaces to listen on for the packet captures
    pub interfaces: Vec<String>,

    /// the ip or hostname of the end server to send the resulting pcap
    srv_addr: String,

    /// the port to send the pcap to
    srv_port: usize,
}

impl ClientConfig {
    pub fn from_path<P: AsRef<Path>>(path: P) -> Result<ClientConfig, ConfigError> {
        // todo: handle toml parsing error
        // todo: handle config errors
        //   script_dir | pcap_dir is not a dir, etc
        let content = fs::read_to_string(path)?;

        match toml::from_str(content.as_str()) {
            Ok(cfg) => Ok(cfg),
            Err(err) => Err(ConfigError::from(err)),
        }
    }

    /// Run all scripts found in the configured scrip directory and block until all are complete
    /// todo: consider replacing with Runner struct
    pub fn run_scripts(&self) -> Result<(), IoError> {
        let mut children: Vec<Child> = vec![]; // will not always be used

        for entry in self.script_dir.read_dir()? {
            let entry = entry?;
            let path = entry.path();
            let child = Command::new(path.to_str().unwrap()).spawn();

            if let Err(err) = child {
                eprintln!(
                    "Couldn't execute script at '{}': {}",
                    path.to_str().unwrap(),
                    err.to_string()
                );
                break;
            };

            let mut child = child.unwrap();

            if self.allow_concurrent {
                child.wait();
            } else {
                children.push(child);
            }
        }

        if !children.is_empty() {
            for mut child in children {
                child.wait();
            }
        }

        Ok(())
    }

    pub fn transfer_pcaps(&self) {
        todo!("transfer all pcap files in self.pcap_dir to the remote (or local) analysis server")
    }
}
